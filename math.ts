/*
 * This file was automatically generated by as-witx - Do not edit manually.
 */

export type handle = i32;
export type char = u8;
export type ptr<T> = usize;
export type mut_ptr<T> = usize;
export type untyped_ptr = usize;
export type struct<T> = usize;
export type union<T> = usize;
export type wasi_string_ptr = ptr<char>;

@unmanaged
export class WasiString {
  ptr: wasi_string_ptr;
  length: usize;

  constructor(str: string) {
    let wasiString = String.UTF8.encode(str, false);
    // @ts-ignore: cast
    this.ptr = changetype<wasi_string_ptr>(wasiString);
    this.length = wasiString.byteLength;
  }

  toString(): string {
    let tmp = new ArrayBuffer(this.length as u32);
    memory.copy(changetype<usize>(tmp), this.ptr, this.length);
    return String.UTF8.decode(tmp);
  }
}

@unmanaged
export class WasiArray<T> {
  ptr: ptr<T>;
  length: usize;

  constructor(array: ArrayBufferView) {
    // @ts-ignore: cast
    this.ptr = array.dataStart;
    this.length = array.byteLength;
  }
}

// @ts-ignore: decorator
@unmanaged
export class Vec3 {
  x: f32;
  y: f32;
  z: f32;
}
// @ts-ignore: decorator
@unmanaged
export class Quat {
  x: f32;
  y: f32;
  z: f32;
  w: f32;
}
// @ts-ignore: decorator
@unmanaged
export class Errno {
  tag: u32;
  private __pad64_0: u64;

  constructor(tag: u32) {
    this.tag = tag;
    memory.fill(changetype<usize>(this) + 4, 0, 4);
  }

  // @ts-ignore: default
  static new<T>(tag: u8, val: T = 0): Errno {
    let tu = new Errno(tag);
    tu.set(val);
    return tu;
  }

  get<T>(): T {
    // @ts-ignore: cast
    let valBuf = changetype<usize>(this) + 4;
    if (isReference<T>()) {
      return changetype<T>(valBuf);
    } else {
      return load<T>(valBuf);
    }
  }

  // @ts-ignore: default
  set<T>(val: T = 0): void {
    // @ts-ignore: cast
    let valBuf = changetype<usize>(this) + 4;
    memory.fill(valBuf, 0, 4);
    if (isReference<T>()) {
      val !== null &&
        memory.copy(valBuf, changetype<usize>(val), offsetof<T>());
    } else {
      store<T>(valBuf, val);
    }
  }

  // --- ok: void if tag=0

  static ok(): Errno {
    return Errno.new(0);
  }

  set_ok(): void {
    this.tag = 0;
  }

  is_ok(): bool {
    return this.tag === 0;
  }

  // --- missing_memory: void if tag=1

  static missing_memory(): Errno {
    return Errno.new(1);
  }

  set_missing_memory(): void {
    this.tag = 1;
  }

  is_missing_memory(): bool {
    return this.tag === 1;
  }
}
export function unit_z(): WasiResult<Vec3, Errno> {
  let rp0 = new Vec3();
  let ret = wasm_glam.unit_z(changetype<usize>(rp0));
  return ret == 0
    ? WasiResult.ok(load<Vec3>(changetype<usize>(rp0)))
    : WasiResult.err(new Errno(ret as u32));
}

export function normalize(v: Vec3): WasiResult<Vec3, Errno> {
  let rp0 = new Vec3();
  let ret = wasm_glam.normalize(changetype<usize>(v), changetype<usize>(rp0));
  return ret == 0
    ? WasiResult.ok(load<Vec3>(changetype<usize>(rp0)))
    : WasiResult.err(new Errno(ret as u32));
}

export function mul_vec3(q: Quat, v: Vec3): WasiResult<Vec3, Errno> {
  let rp0 = new Vec3();
  let ret = wasm_glam.mul_vec3(
    changetype<usize>(q),
    changetype<usize>(v),
    changetype<usize>(rp0)
  );
  return ret == 0
    ? WasiResult.ok(load<Vec3>(changetype<usize>(rp0)))
    : WasiResult.err(new Errno(ret as u32));
}

export namespace WasmGlam {
  export declare function unit_z(arg0: i32): i32;
  export declare function normalize(arg0: i32, arg1: i32): i32;
  export declare function mul_vec3(arg0: i32, arg1: i32, arg2: i32): i32;
}

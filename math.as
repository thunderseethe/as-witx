
/*
 * This file was automatically generated by as-witx - Do not edit manually.
 */
import { * } from 'common';

// @ts-ignore: decorator
@unmanaged
export class Vec3 {
    x: f32;
    y: f32;
    z: f32;
}
// @ts-ignore: decorator
@unmanaged
export class Quat {
    x: f32;
    y: f32;
    z: f32;
    w: f32;
}
// @ts-ignore: decorator
@unmanaged
export class Errno {
    tag: u32;
    private __pad64_0: u64;

    constructor(tag: u32) {
        this.tag = tag;
        memory.fill(changetype<usize>(this) + 4, 0, 4);
    }

    // @ts-ignore: default
    static new<T>(tag: u8, val: T = 0): Errno {
        let tu = new Errno(tag);
        tu.set(val);
        return tu;
    }

    get<T>(): T {
        // @ts-ignore: cast
        let valBuf = changetype<usize>(this) + 4;
        if (isReference<T>()) {
            return changetype<T>(valBuf);
        } else {
            return load<T>(valBuf);
        }
    }

    // @ts-ignore: default
    set<T>(val: T = 0): void {
        // @ts-ignore: cast
        let valBuf = changetype<usize>(this) + 4;
        memory.fill(valBuf, 0, 4);
        if (isReference<T>()) {
            (val !== null) && memory.copy(valBuf, changetype<usize>(val), offsetof<T>());
        } else {
            store<T>(valBuf, val)
        }
    }

    // --- ok: void if tag=0

    static ok(): Errno {
        return Errno.new(0);
    }

    set_ok(): void {
        this.tag = 0;
    }

    is_ok(): bool {
        return this.tag === 0;
    }

    // --- missing_memory: void if tag=1

    static missing_memory(): Errno {
        return Errno.new(1);
    }

    set_missing_memory(): void {
        this.tag = 1;
    }

    is_missing_memory(): bool {
        return this.tag === 1;
    }
}
export function unit_z(): WasiResult<Vec3, Errno>{
let rp0 = new Vec3();
let ret = wasm_glam.unit_z(changetype<usize>(rp0));if ret == 0 { WasiResult.ok(load<Vec3>(changetype<usize>(rp0))) } else { WasiResult.err(new Errno(ret as u32)) }}


export function normalize(v: Vec3): WasiResult<Vec3, Errno>{
let rp0 = new Vec3();
let ret = wasm_glam.normalize(changetype<usize>(v),changetype<usize>(rp0));if ret == 0 { WasiResult.ok(load<Vec3>(changetype<usize>(rp0))) } else { WasiResult.err(new Errno(ret as u32)) }}


export function mul_vec3(q: Quat, v: Vec3): WasiResult<Vec3, Errno>{
let rp0 = new Vec3();
let ret = wasm_glam.mul_vec3(changetype<usize>(q),changetype<usize>(v),changetype<usize>(rp0));if ret == 0 { WasiResult.ok(load<Vec3>(changetype<usize>(rp0))) } else { WasiResult.err(new Errno(ret as u32)) }}


export namespace WasmGlam{
export declare function unit_z(arg0: i32, ): i32;
export declare function normalize(arg0: i32, arg1: i32, ): i32;
export declare function mul_vec3(arg0: i32, arg1: i32, arg2: i32, ): i32;
}
